#!/bin/sh -efu
#
# Copyright (C) 2015  Paul Wolneykien <manowar@altlinux.org>
# Copyright (C) 2015  STC Metrotek [http://metrotek.spb.ru/]
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

PROG="${PROG:-${0##*/}}"
PROG_VERSION="0.2.0"
PROG_PATH="${0%/*}"

. "$PROG_PATH/pocket-functions.sh"

POCKETDIR="${POCKETDIR:-$DEFPOCKETDIR}"
MAKE="${MAKE:-make}"

show_help() {
    cat <<EOF
Usage: $PROG [ options ] [ACTION] [action arguments]

$PROG invokes the specified Pocketfile action or one of the
built in pseudo-actions. Without an action specified invokes
the default Pocketfile action or shows this help page if
Pocketfile doesn't exist.

Use \`$PROG init\` to initialize the empty pocket and
\`$PROG init --help\` for its usage information.

Options:

  -C POCKETDIR, --dir=POCKETDIR     the pocket directory containing
                                    a Pocketfile; the default is
                 ~/pocket; can also be specified via the POCKETDIR
                 environment variable;

  -a <arch>, --arch=<arch>    supply the \`ARCH=<arch>\` Pocketfile
                              parameter;

  -t <cross-arch>,
  --target=<cross-arch>       supply the \`TARGET=<cross-arch>\`
                              Pocketfile parameter;

  -n, --network    supply the \`SHARE_NETWORK=yes\` Pocketfile
                   parameter;

  -q, --quiet    suppress output;

  -d, --debug    turn on the debugging output;

  --deep-debug   equvalent of double \`-d\` option, turns on the
                 internal rule debugging;

  -n, --dry-run  print the commands that would be executed, but do
                 not execute them;

  -h, --help     show this help page and exit;

  -V, --version  print the program version information and exit.


Pseudo-actions:

  init [args]  invokes the pocket-init util with arguments specified;
               invoke \`$PROG init --help\` to get its usage
               information.

Action wrappers:

  install <packages...>    invokes the Pocketfile \`install\` action
                           with the specified list of packages
                           as PKGS=<packages...>;

  help [subject]    invokes the Pocketfile \`help\` action with the
                    subject as SUBJ=<subject> if specified;

  doc [subject]     same as the above but invokes the \`doc\` action;

  sync-in [-o|--over] <from>    invokes the Pocketfile \`sync-in\`
                              action with <from> directory path as
                    FROM=<from>; the \`-o|--over\` option corresponds
                    to the \`OVER=yes\` parameter;

  sync-out <to>     complementary to the above action supplying <to>
                    directory as TO=<to>;

  shell [--rooter]  invokes the Pocketfile \`shell\` action; the
                    option \`--rooter\` passes \`ROLE=rooter\`
                    parameter;

  install-shell [--rooter]    same as the above but for the
                              \`install-shell\` Pocketfile action.

EOF
    exit 0
}


## Functions

do_invoke()
{
    local normal=
    [ ${debug:-0} -gt 0 ] || normal=1
    local deep=
    [ ${debug:-0} -le 1 ] || deep=1

    "$MAKE" -w -r ${normal:+-s} ${quiet:+--no-print-directory} \
            ${deep:+-d} ${dry:+-n} \
            -C "${POCKETDIR%/}" -f "$POCKETFILE" \
        "$@" ${debug:+DEBUG=yes}
}

invoke()
{
    if [ -n "$quiet" ]; then
        do_invoke "$action" "$@" >/dev/null
    else
        do_invoke "$action" "$@"
    fi
}

quote()
{
    printf '%s\n' "$*" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'
}

## Special cases:

if [ -n "${1:-}" ]; then
    case "$1" in
        install)
            params=; pkgs=
            for a in "$@"; do
                case "$a" in
                    *=*)
                        name="${a%%=*}"
                        val="${a#*=}"
                        [ -z "$params" ] || params="$params "
                        params="${params}$name=\"$(quote "$val")\""
                        ;;
                    *)
                        [ -z "$pkgs" ] || pkgs="$pkgs "
                        pkgs="${pkgs}$a"
                        ;;
                esac
            done

            [ -n "$pkgs" ] || fatal 'No packages specified\n'

            eval "invoke install PKGS=\"$(quote "$pkgs")\" $params"
            exit 0
            ;;
        help|doc)
            action="$1"; shift
            if [ $# -gt 0 ]; then
                subj="$1"; shift
                invoke "$action" SUBJ="$subj" "$@"
            else
                invoke "$action" "$@"
            fi
            exit 0
            ;;
        sync-in|sync-out)
            action="$1"; shift

            OPTS=`getopt -n "$PROG sync-in" -o o -l over -- "$@"` || ( ret=$?; show_usage; exit $ret ) >&2
            eval set -- "$OPTS"

            dir=; over=

            while :; do
                case "$1" in
                    -o|--over) over=yes;;
                    --) shift; break;;
                    *)
                        fatal 'Unrecognized option: %s\n' "$1"
                        ;;
                esac
                shift
            done

            if [ $# -gt 0 ]; then
                dir="$1"; shift
                case "$dir" in
                    /*)
                        ;;
                    *)
                        dir="$(pwd)/$dir"
                        ;;
                esac
            fi

            case "$action" in
                sync-in)
                    [ -n "$dir" ] || \
                        fatal 'Source directory is not specified\n'
                    invoke 'sync-in' FROM="$dir" "$@" ${over:+OVER=yes}
                    ;;
                sync-out)
                    [ -n "$dir" ] || \
                        fatal 'Destination directory is not specified\n'
                    invoke 'sync-out' TO="$dir" "$@"
                    ;;
                *)
                    fatal 'BUG!\n'
                    ;;
            esac

            exit 0
            ;;
        init)
            shift
            "$PROG_PATH/pocket-init" "$POCKETDIR" "$@"
            exit 0
            ;;
    esac
fi


## Argument parsing

OPTS=`getopt -n $PROG -o C:,q,d,n,h,V -l dir:,quiet,debug,deep-debug,dry-run,help,version -- "$@"` || ( ret=$?; show_usage; exit $ret ) >&2

eval set -- "$OPTS"

dir=; quiet=; debug=; dry=

while :; do
    case "$1" in
        -C|--dir)
            shift
            POCKETDIR="$1"
            ;;
        -q|--quiet) quiet=-q;;
        -d|--debug)
            [ -n "$debug" ] || debug=0
            debug=$((debug + 1))
            ;;
        --deep-debug)
            [ ${debug:-0} -gt 1 ] || debug=2
            ;;
        -n|--dry-run) dry=-n;;
        -V|--version) print_version; exit 0;;
        -h|--help) show_help;;
        --) shift; break;;
        *)
            fatal 'Unrecognized option: %s\n' "$1"
            ;;
    esac
    shift
done


## Main

action=

if [ $# -gt 0 ]; then
    action="$1"; shift
fi

if [ -z "$action" ]; then
    if [ -e "${POCKETDIR%/}/$POCKETFILE" ]; then
        invoke "$@"
    else
        show_help
    fi
else
    invoke "$action" "$@"
fi
